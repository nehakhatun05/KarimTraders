"use strict";(()=>{var e={};e.id=798,e.ids=[798],e.modules={53524:e=>{e.exports=require("@prisma/client")},30517:e=>{e.exports=require("next/dist/compiled/next-server/app-route.runtime.prod.js")},32081:e=>{e.exports=require("child_process")},6113:e=>{e.exports=require("crypto")},82361:e=>{e.exports=require("events")},13685:e=>{e.exports=require("http")},95687:e=>{e.exports=require("https")},73837:e=>{e.exports=require("util")},97787:(e,t,a)=>{a.r(t),a.d(t,{headerHooks:()=>g,originalPathname:()=>P,patchFetch:()=>v,requestAsyncStorage:()=>I,routeModule:()=>h,serverHooks:()=>b,staticGenerationAsyncStorage:()=>E,staticGenerationBailout:()=>S});var r={};a.r(r),a.d(r,{POST:()=>l});var i=a(95419),o=a(69108),s=a(99678),n=a(78070),d=a(28291),u=a(34490);let c=null,p=process.env.STRIPE_WEBHOOK_SECRET||"";async function l(e){try{let t;let a=await e.text(),r=e.headers.get("stripe-signature");if(!r)return n.Z.json({error:"Missing signature"},{status:400});try{t=(function(){if(!c){if(!process.env.STRIPE_SECRET_KEY)throw Error("Stripe credentials not configured");c=new d.Z(process.env.STRIPE_SECRET_KEY,{apiVersion:"2025-12-15.clover"})}return c})().webhooks.constructEvent(a,r,p)}catch(e){return await u.Z.webhookLog.create({data:{provider:"STRIPE",event:"SIGNATURE_FAILED",payload:{body:a.substring(0,500)},status:"FAILED",error:e instanceof Error?e.message:"Signature verification failed"}}),n.Z.json({error:"Invalid signature"},{status:400})}let i=await u.Z.webhookLog.create({data:{provider:"STRIPE",event:t.type,payload:t.data.object,status:"PENDING"}});try{switch(t.type){case"checkout.session.completed":await w(t.data.object);break;case"payment_intent.succeeded":await m(t.data.object);break;case"payment_intent.payment_failed":await y(t.data.object);break;case"charge.refunded":await f(t.data.object);break;default:console.log("Unhandled Stripe event:",t.type)}await u.Z.webhookLog.update({where:{id:i.id},data:{status:"SUCCESS"}})}catch(e){console.error("Stripe webhook processing error:",e),await u.Z.webhookLog.update({where:{id:i.id},data:{status:"FAILED",error:e instanceof Error?e.message:"Unknown error"}})}return n.Z.json({received:!0})}catch(e){return console.error("Stripe webhook error:",e),n.Z.json({error:"Webhook processing failed"},{status:500})}}async function w(e){let t=e.metadata?.orderId,a=e.metadata?.walletUserId;if(t&&await u.Z.$transaction(async a=>{let r=await a.order.update({where:{id:t},data:{paymentStatus:"PAID",paymentId:e.payment_intent,status:"CONFIRMED"}});await a.orderTimeline.create({data:{orderId:t,status:"CONFIRMED",title:"Payment Successful",description:"Payment received via Stripe"}}),await a.notification.create({data:{userId:r.userId,type:"ORDER",title:"Payment Successful",message:`Your payment for order #${r.orderNumber} was successful.`,data:{orderId:t}}})}),a&&e.amount_total){let t=e.amount_total/100;await u.Z.$transaction(async r=>{let i=await r.wallet.findUnique({where:{userId:a}});i&&(await r.wallet.update({where:{userId:a},data:{balance:{increment:t}}}),await r.walletTransaction.create({data:{walletId:i.id,type:"CREDIT",amount:t,description:"Added money via Stripe",referenceId:e.id}}),await r.notification.create({data:{userId:a,type:"WALLET",title:"Money Added",message:`₹${t} has been added to your wallet.`,data:{sessionId:e.id}}}))})}}async function m(e){let t=e.metadata?.orderId;if(t){let a=await u.Z.order.findUnique({where:{id:t}});a&&"PAID"!==a.paymentStatus&&await u.Z.order.update({where:{id:t},data:{paymentStatus:"PAID",paymentId:e.id}})}}async function y(e){let t=e.metadata?.orderId;t&&await u.Z.$transaction(async a=>{let r=await a.order.update({where:{id:t},data:{paymentStatus:"FAILED"}});await a.orderTimeline.create({data:{orderId:t,status:"PENDING",title:"Payment Failed",description:e.last_payment_error?.message||"Payment could not be processed"}}),await a.notification.create({data:{userId:r.userId,type:"ORDER",title:"Payment Failed",message:`Payment for order #${r.orderNumber} failed. Please try again.`,data:{orderId:t}}})})}async function f(e){let t=e.metadata?.orderId;t&&e.amount_refunded&&await u.Z.$transaction(async a=>{let r=await a.order.findUnique({where:{id:t}});r&&(await a.order.update({where:{id:t},data:{paymentStatus:"REFUNDED"}}),await a.orderTimeline.create({data:{orderId:t,status:r.status,title:"Refund Processed",description:`Refund of ₹${e.amount_refunded/100} processed`}}),await a.notification.create({data:{userId:r.userId,type:"ORDER",title:"Refund Processed",message:`Refund of ₹${e.amount_refunded/100} for order #${r.orderNumber} has been processed.`,data:{orderId:t}}}))})}let h=new i.AppRouteRouteModule({definition:{kind:o.x.APP_ROUTE,page:"/api/webhooks/stripe/route",pathname:"/api/webhooks/stripe",filename:"route",bundlePath:"app/api/webhooks/stripe/route"},resolvedPagePath:"C:\\Users\\basan\\Desktop\\karim123\\KarimTraders\\src\\app\\api\\webhooks\\stripe\\route.ts",nextConfigOutput:"",userland:r}),{requestAsyncStorage:I,staticGenerationAsyncStorage:E,serverHooks:b,headerHooks:g,staticGenerationBailout:S}=h,P="/api/webhooks/stripe/route";function v(){return(0,s.patchFetch)({serverHooks:b,staticGenerationAsyncStorage:E})}},34490:(e,t,a)=>{a.d(t,{Z:()=>o,_:()=>i});var r=a(53524);let i=globalThis.prisma??new r.PrismaClient({log:["error"]}),o=i}};var t=require("../../../../webpack-runtime.js");t.C(e);var a=e=>t(t.s=e),r=t.X(0,[1638,6206,735,8291],()=>a(97787));module.exports=r})();